using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ITI.GameCore
{
    //struct for can move to answer
    public struct PossibleMove
    {
        public readonly int X;
        public readonly int Y;
        public readonly List<StudiedPawn> FreeSquares;
        public readonly Pawn Value;
        /// <summary>
        /// Initializes a new instance of the <see cref="PossibleMove" /> struct.
        /// </summary>
        /// <param name="x">The x position of the analyzed pawn.</param>
        /// <param name="y">The y position of the analyzed pawn.</param>
        /// <param name="freeSquares">The free squares.</param>
        /// <param name="value">The value.</param>
        public PossibleMove(int x, int y, List<StudiedPawn> freeSquares, Pawn value)
        {
            X = x;
            Y = y;
            FreeSquares = freeSquares;
            Value = value;
        }
        public bool IsFree
        {
<<<<<<< HEAD
            get { 
            if (FreeSquares.Count == 0) return false;
            return true;
=======
            get
            {
                if (FreeSquares.Count == 0) return false;
                return true;
>>>>>>> GameCore.Test
            }
        }
        public int Up
        {
<<<<<<< HEAD
            get { 
            int up = 0;
            foreach (StudiedPawn value in FreeSquares)
=======
            get
>>>>>>> GameCore.Test
            {
                int up = 0;
                foreach (StudiedPawn value in FreeSquares)
                {
                    if (value.X == X && value.Y < Y) up++;
                }
                return up;
            }
<<<<<<< HEAD
            return up;
            }
        }
        public int Down
        {
            get { 
            int down = 0;
            foreach (StudiedPawn value in FreeSquares)
=======
        }
        public int Down
        {
            get
>>>>>>> GameCore.Test
            {
                int down = 0;
                foreach (StudiedPawn value in FreeSquares)
                {
                    if (value.X == X && value.Y > Y) down++;
                }
                return down;
            }
<<<<<<< HEAD
            return down;
            }
        }
        public int Left
        {
            get { 
            int left = 0;
            foreach (StudiedPawn value in FreeSquares)
=======
        }
        public int Left
        {
            get
>>>>>>> GameCore.Test
            {
                int left = 0;
                foreach (StudiedPawn value in FreeSquares)
                {
                    if (value.X < X && value.Y == Y) left++;
                }
                return left;
            }
<<<<<<< HEAD
            return left;
            }
        }
        public int Right
        {
            get { 
            int right = 0;
            foreach (StudiedPawn value in FreeSquares)
=======
        }
        public int Right
        {
            get
>>>>>>> GameCore.Test
            {
                int right = 0;
                foreach (StudiedPawn value in FreeSquares)
                {
                    if (value.X > X && value.Y == Y) right++;
                }
                return right;
            }
<<<<<<< HEAD
            return right;
            }
=======
>>>>>>> GameCore.Test
        }
    }
    public struct StudiedPawn
    {
        public readonly int X;
        public readonly int Y;

        public StudiedPawn(int x, int y)
        {
            X = x;
            Y = y;
        }
    }
    static public class Helper
    {
        static internal void CheckRange(int width, int height, int x, int y)
        {
            if (x < 0 || x > width) throw new ArgumentOutOfRangeException("Can't aim out of the tafl", nameof(x));
            if (y < 0 || y > height) throw new ArgumentOutOfRangeException("Can't aim out of the tafl", nameof(y));

        }

        #region Checkers for emptyness
        /// <summary>
        /// Checks if the pawn above/down/left/right is empty, if so, return true.
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <returns></returns>
        static public bool CheckUp(int x, int y, IReadOnlyTafl _tafl)
        {
            if (y - 1 < 0 || _tafl[x, y - 1] != Pawn.None) return false;
            if (_tafl[x, y - 1] == Pawn.None) return true;
            return false;
        }
        static public bool CheckDown(int x, int y, IReadOnlyTafl _tafl)
        {
            if (y + 1 >= _tafl.Height || _tafl[x, y + 1] != Pawn.None) return false;
            if (_tafl[x, y + 1] == Pawn.None) return true;
            return false;
        }
        static public bool CheckLeft(int x, int y, IReadOnlyTafl _tafl)
        {
            if (x - 1 < 0 || _tafl[x - 1, y] != Pawn.None) return false;
            if (_tafl[x - 1, y] == Pawn.None) return true;
            return false;
        }
        static public bool CheckRight(int x, int y, IReadOnlyTafl _tafl)
        {
            if (x + 1 >= _tafl.Width || _tafl[x + 1, y] != Pawn.None) return false;
            if (_tafl[x + 1, y] == Pawn.None) return true;
            return false;
        }
        #endregion
        /// <summary>
        /// Checks the walls pawn, forteress corner and throne If detected return true.
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <returns></returns>
        static public bool CheckWalls(int x, int y, IReadOnlyTafl _tafl) //temp, send that to toolbox;
        {
            if ((_tafl[x, y] == Pawn.Wall)
                || (x == 0 && y == 0)  //Top left corner
                || (x == 0 && y == _tafl.Height - 1) //Bot left corner
                || (x == _tafl.Width - 1 && y == 0)  //top right corner
                || (x == _tafl.Width - 1 && y == _tafl.Height - 1)  //Bot right corner
                || (x == (_tafl.Width - 1) / 2 && y == (_tafl.Height - 1) / 2 && (_tafl[((_tafl.Width - 1) / 2), ((_tafl.Height - 1) / 2)]) == Pawn.None)//Throne only if empty
                ) return true;
            return false;
        }
    }
}